What is immutable class, and how do you create one?

An immutable class is a class whose objects cannot be modified after creation. 
If any change is required, a new object must be created instead of modifying the existing one.

To make a class immutable, follow these 5 rules:
Declare the class as final (so it cannot be extended).
Make all fields private and final (so they cannot be changed).
Do not provide setters (no methods to modify fields).
Initialize all fields in the constructor (so they can be set only once).
Return defensive copies of mutable objects instead of direct references.

String is immutable in Java. Once a String object is created, its value cannot be changed. Any modification to a String creates 
a new object instead of changing the existing one.
Since String is immutable, Java provides StringBuilder (mutable alternative) for better performance when modifying strings frequently.
----------------------------------------------------------------------------------------------------------------------------------
difference b/w String buffer and String Builder?

Both StringBuffer and StringBuilder are mutable (modifiable) versions of String. The key difference lies in synchronization and performance.

Feature	                StringBuffer	                        StringBuilder     
-----------            -----------------                        -----------------
Mutability	         Mutable (modifiable)	                   Mutable (modifiable)
Thread Safety	       ‚úÖ Thread-safe (Synchronized)	         ‚ùå Not thread-safe (Faster)
Performance	         Slower due to synchronization	         Faster (No synchronization)
Usage	               Multi-threaded environments	           Single-threaded applications

----------------------------------------------------------------------------------------------------------------------------------
what are the iterators, how many types of iterators are there

Feature	                         Iterator	             ListIterator	                    Enumeration
-----------                       -----------          -----------                      -----------
Applicable Collections	         List, Set, Queue	       List only	                    Vector, Hashtable
Forward Traversal	               ‚úÖ Yes                 	‚úÖ Yes	                      ‚úÖ Yes
Backward Traversal	             ‚ùå No	                  ‚úÖ Yes	                      ‚ùå No
Modification Allowed	           ‚úÖ (Only remove())	      ‚úÖ (add(), remove(), set())	‚ùå No
Thread-Safety	                   ‚ùå No	                  ‚ùå No	                         ‚úÖ Yes
Usage	                           Modern collections	      Only for List	                 Legacy classes
Methods                  hasNext(), next(), iterator()   hasPrevious, previous()         hasMoreElements(), nextElement(), .elements()
----------------------------------------------------------------------------------------------------------------------------------
how may types of interfaces are there?

Java provides different types of interfaces based on their structure and functionality. Below are the 5 main types of interfaces:

1Ô∏è‚É£ Normal Interface (Regular Interface)
A normal interface contains only abstract methods (before Java 8). From Java 8 onwards, it can also have default and static methods.
‚úÖ Key Points:
Contains only abstract methods (before Java 8).
Can have default and static methods (from Java 8).
Used for multiple inheritance.

2Ô∏è‚É£ Functional Interface
A functional interface has exactly one abstract method. It can have default and static methods.
‚úÖ Key Points:
Contains exactly one abstract method.
Can have multiple default and static methods.
Used in Lambda Expressions & Functional Programming.
Examples: Runnable, Callable, Comparator.

3Ô∏è‚É£ Marker Interface
A marker interface has no methods or fields. It is used to signal the JVM that a class has special behavior.
‚úÖ Key Points:
Used to mark a class for special behavior.
Examples: Serializable, Cloneable, Remote.

4Ô∏è‚É£ Tagging Interface (Similar to Marker Interface)
A tagging interface is similar to a marker interface but is used for categorization in frameworks like Spring and Hibernate.
‚úÖ Key Points:
Used in Spring, Hibernate, and Java EE.
Example: Remote in RMI.

5Ô∏è‚É£ Nested Interface (Inner Interface)
An interface declared inside another interface or class.
‚úÖ Key Points:
Used for grouping related functionality.
Example: Map.Entry (inside Map).
----------------------------------------------------------------------------------------------------------------------------------
Comparison of contains() in Different Collections

Collection	                     Implementation	                            Time Complexity
------------                     ------------                              ------------
ArrayList	                   Linear Search (indexOf(), uses .equals())	    O(n)
LinkedList	                 Iterates nodes (uses .equals())	              O(n)
HashSet	                     Hashing + .equals()	                          O(1) (avg.), O(n) (worst)
TreeSet                      Binary Search Tree (compareTo())	              O(log n)
HashMap.containsKey()	       Hashing + .equals()	                          O(1) (avg.), O(n) (worst)
----------------------------------------------------------------------------------------------------------------------------------
How distinct() Works Internally in Java Streams

@Override
public Stream<T> distinct() {
    return boxed().collect(Collectors.toCollection(LinkedHashSet::new)).stream();
}

Uses a LinkedHashSet
The LinkedHashSet maintains insertion order and ensures uniqueness.
This is why distinct() keeps the original order.
Collects elements into a LinkedHashSet first, then converts back to a stream.

By default, distinct() relies on .equals() and hashCode().
For custom objects, override these methods.

@Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Employee employee = (Employee) o;
        return id == employee.id && Objects.equals(name, employee.name);
    }

    @Override
    public int hashCode() {
        return Objects.hash(id, name);
    }
----------------------------------------------------------------------------------------------------------------------------------

What is the purpose of the final keyword in Java?

The final keyword in Java is a non-access modifier used to impose restrictions on variables, methods, and classes, ensuring immutability or preventing modification in specific ways

Final Variables
When a variable is declared as final, its value can be assigned only once. After initialization, it cannot be changed, making it a constant.
Example: final int MAX_USERS = 100;
For instance variables, final allows initialization either at declaration or within the constructor.

Final Methods
Declaring a method as final prevents subclasses from overriding it. This is useful when you want to ensure that the method's implementation remains unchanged 
for security, consistency, or performance reasons.
Example:
class Parent {
    public final void show() {
        System.out.println("This method cannot be overridden.");
    }
}
Subclasses attempting to override a final method will result in a compilation error.

Final Classes
A class marked as final cannot be extended (subclassed) by any other class. This is often used to prevent inheritance for security or design reasons.
Example:
public final class Utility {
    // Class code
}
No other class can inherit from a final class

-------------------------------------------------------------------------------------------------------------------

Explain the difference between ArrayList and LinkedList.

The main difference between ArrayList and LinkedList in Java lies in their underlying data structures and how they handle operations like access, insertion, and deletion.

Underlying Data Structures
ArrayList uses a dynamic array to store elements. All elements are stored in contiguous memory locations, allowing fast access via indices.
LinkedList uses a doubly linked list. Each element (node) contains the data and references to the previous and next nodes. Elements are not stored in contiguous memory, 
but are connected via pointers.

Choose ArrayList when you need fast random access and your application involves more read/search operations than insertions or deletions.
Choose LinkedList when your application requires frequent additions or removals of elements, especially at the beginning or middle of the list

-------------------------------------------------------------------------------------------------------------------
What is the super keyword and how is it used?

The super keyword in Java is used to refer to the immediate parent (superclass) of a class. It is primarily used in three ways:

Usage	                               Syntax	                    Purpose
Call parent method	              super.methodName()	    Invoke overridden method from parent class
Call parent constructor	          super() or super(args)	Invoke parent class constructor in subclass constructor
Access parent field	              super.fieldName	        Access field from parent class when shadowed in subclass

-------------------------------------------------------------------------------------------------------------------
What is a marker interface?

A marker interface in Java is an interface that does not contain any methods, fields, or constants-in other words, it is completely empty. 
Its primary purpose is to provide metadata or a signal to the Java Virtual Machine (JVM) or Java APIs that a class implementing this interface should be treated in a special way.

How Marker Interfaces Work
When a class implements a marker interface, it does not have to implement any methods.
The presence of the marker interface allows runtime or compile-time mechanisms (such as the JVM or certain Java libraries) 
to recognize that the class has a specific property or should receive special behavior.
Marker interfaces are also called tag interfaces.

-------------------------------------------------------------------------------------------------------------------

What is a Singleton class and how do you implement it in Java?

A Singleton class in Java is a design pattern that ensures a class has only one instance throughout the application's lifecycle and provides a global point of access to that instance. This is useful for managing shared resources like configuration settings, logging, caches, or connection pools.

Key Characteristics of a Singleton
Single Instance: Only one object of the class exists.
Global Access: The instance is accessible globally via a static method.
Private Constructor: Prevents other classes from instantiating the class directly.
Thread Safety: In multi-threaded environments, ensures only one instance is created.
 
Method	               Thread Safe	Lazy       Loaded	Notes
Eager Initialization	  Yes	     No	       Simple, but may waste resources
Lazy Initialization	      Yes 	     Yes	   Synchronized, slower
Double-Checked Locking	  Yes	     Yes	   Efficient and safe
Enum Singleton	          Yes	     Yes	   Most robust, recommended

-------------------------------------------------------------------------------------------------------------------

What is the difference between checked and unchecked exceptions?

The difference between checked and unchecked exceptions in Java centers on when they are detected and how they are handled by the compiler and the programmer.

Checked Exceptions
Detected at compile time: The Java compiler checks for these exceptions during compilation. If a method can throw a checked exception, 
it must either handle it with a try-catch block or declare it with a throws clause in the method signature.
Examples: IOException, SQLException, ClassNotFoundException.
Purpose: Usually represent conditions that a program can anticipate and recover from, such as file operations or database access issues.
Must be handled: The compiler enforces handling or declaration of checked exceptions, ensuring the programmer addresses potential error conditions.

Unchecked Exceptions
Detected at runtime: These exceptions are not checked at compile time. The compiler does not require methods to handle or declare them.
Examples: NullPointerException, ArrayIndexOutOfBoundsException, ArithmeticException.
Purpose: Usually represent programming errors, such as logic mistakes or improper use of APIs (e.g., accessing a null object or dividing by zero).
No mandatory handling: The compiler does not force the programmer to handle unchecked exceptions, though they can still be caught and managed if desired

-------------------------------------------------------------------------------------------------------------------

Explain the difference between == and .equals() in Java.

The difference between == and .equals() in Java lies in what they compare and how they are used:

== Operator
Purpose: Compares references (memory addresses) for objects and values for primitives.
With primitives: Checks if the values are the same.
With objects: Checks if both references point to the exact same object in memory.

.equals() Method
Purpose: Compares the contents (state) of two objects.
Default behavior: In the Object class, .equals() behaves like == (reference comparison).
Overridden behavior: Many classes (like String, Integer) override .equals() to compare actual data inside objects.
Cannot be used on primitives: Only works on objects.
Can be overridden: Classes can provide their own logic for what it means for two instances to be "equal"

-------------------------------------------------------------------------------------------------------------------
What is a Java Package and why is it used?

A Java package is a mechanism for grouping related classes, interfaces, and sub-packages into a single namespace, much like folders in a file system. 
Packages help organize code logically, making it easier to manage, locate, and maintain, especially in large or complex projects

Types of Packages
Built-in Packages: Provided by Java (e.g., java.util, java.io), containing standard classes and interfaces.
User-defined Packages: Created by developers to organize their own project‚Äôs classes and interfaces.

-------------------------------------------------------------------------------------------------------------------
How does try-catch-finally work in Java?

The try-catch-finally construct in Java is used for robust exception handling and resource management.

How It Works
1. try Block
Contains code that might throw an exception.
If an exception occurs, the rest of the try block is skipped, and control moves to the matching catch block.

2. catch Block
Handles the specific exception thrown in the try block.
You can have multiple catch blocks to handle different exception types.
If the exception matches the type specified in the catch, the code inside that catch block executes.

3. finally Block
Contains code that will always execute after the try and catch blocks, regardless of whether an exception was thrown or caught.
Commonly used for cleanup activities, such as closing files or releasing resources.
The finally block executes even if there is a return statement in the try or catch block, or if an exception is thrown and not caught.
The only exceptions to this are if the JVM exits (e.g., via System.exit()) or if the thread is killed before the finally block executes.

-------------------------------------------------------------------------------------------------------------------

What is the this keyword in Java and where is it used?

The this keyword refers to the current object in Java and is essential for resolving naming conflicts, invoking class methods and constructors, 
passing or returning the current object, and accessing outer class instances from inner classes

Important Notes
this cannot be used in static contexts, as static methods are not tied to any particular object instance.
It is a reserved keyword in Java and cannot be used as an identifier.

-------------------------------------------------------------------------------------------------------------------

What is the Java Collections Framework? Name some important interfaces and classes.

The Java Collections Framework is a unified architecture that provides a set of interfaces and classes for storing, retrieving, and manipulating groups of objects efficiently. 
It standardizes how collections of data are handled in Java, making it easier to write reusable, high-performance, and maintainable code

Important Interfaces
Interface	       Description
Collection	  Root interface for most collection classes; defines basic operations.
List	      Ordered collection; allows duplicates (e.g., ArrayList, LinkedList).
Set	          Unordered collection; no duplicate elements (e.g., HashSet, TreeSet).
Queue	      For holding elements prior to processing, typically in FIFO order.
Map	          Stores key-value pairs; keys are unique (e.g., HashMap, TreeMap).
Note: Map is not a true subinterface of Collection, but is fully integrated with the framework.

Important Classes
Class	     Implements	                Description
ArrayList	   List	                Dynamic array, fast random access.
LinkedList	   List, Deque	        Doubly-linked list, efficient insertions.
HashSet	       Set	                Hash table-based set, no duplicates.
TreeSet	       Set, SortedSet	    Sorted set using a red-black tree.
HashMap	       Map	                Hash table-based map, fast lookup.
TreeMap	       Map, SortedMap	    Sorted map using a red-black tree.
PriorityQueue  Queue	            Elements ordered by priority.
Stack, Vector  List	                Legacy classes for stack and dynamic array.

-------------------------------------------------------------------------------------------------------------------

How does Java handle memory management?

Java handles memory management automatically through the Java Virtual Machine (JVM), with the Garbage Collector (GC) playing a central role. Here‚Äôs how it works:

JVM Memory Management
The JVM divides memory into different regions, primarily the heap (where objects are stored) and other areas for method calls and stack frames.
When a Java application runs, the JVM allocates memory for new objects on the heap.
As the program executes, some objects become unreachable (no longer referenced by any part of the code).

Role of the Garbage Collector
Automatic Memory Management: The Garbage Collector automatically identifies and removes objects that are no longer reachable, freeing up memory and preventing memory leaks.
Mark-and-Sweep Algorithm: The GC typically uses a mark-and-sweep approach:
Mark phase: It traverses the object graph from root references and marks all reachable objects.
Sweep phase: It reclaims memory occupied by unmarked (unreachable) objects.
Generational Collection: The JVM heap is divided into generations (young and old). Most new objects are allocated in the young generation, 
and those that survive several garbage collection cycles are moved to the old generation. Minor GC handles short-lived objects quickly, 
while Major GC deals with long-lived objects and takes longer.
Stop-the-World Events: During garbage collection, all application threads are paused until the process completes, ensuring consistency.

Benefits
No Manual Memory Management: Developers don‚Äôt need to explicitly allocate or free memory, reducing errors and improving productivity.
Prevents Memory Leaks: By reclaiming unused memory, the GC helps prevent memory leaks and related performance issues.
Optimized Performance: The GC can optimize memory usage and improve application stability and efficiency

-------------------------------------------------------------------------------------------------------------------
What is the difference between HashMap and TreeMap?

The main differences between HashMap and TreeMap in Java are based on their underlying data structures, ordering, performance, and key/value constraints:

Feature	                            HashMap	                                                          TreeMap
Ordering	               No guaranteed order of keys or values	                          Maintains keys in sorted (ascending) order
Underlying Structure	   Hash table (array of buckets, uses hashing)	                      Self-balancing Red-Black tree
Performance	               O(1) average time for put/get/remove (fastest)	                  O(log n) time for put/get/remove
Null Keys/Values	       Allows one null key and multiple null values	                      Does not allow null keys, but allows null values
Use Case	               Best for fast, unordered access; when order doesn't matter	      Best when sorted order of keys is needed
Interface Implemented	   Implements Map, Cloneable, Serializable	                          Implements NavigableMap, SortedMap, Cloneable, Serializable
Key Requirements	       Keys must implement proper hashCode() and equals() methods	      Keys must be Comparable or provided with a Comparator

Summary
HashMap is preferred for most cases due to its fast O(1) operations and support for null keys, but it does not maintain any order of the keys or values.
TreeMap is used when you need the keys to be sorted in natural or custom order, but its operations are slower (O(log n)) and it does not allow null keys.

In short:
Use HashMap for fast, unordered key-value storage. Use TreeMap when you need your keys sorted automatically

-------------------------------------------------------------------------------------------------------------------
What is the purpose of the transient keyword?

When a field is marked as transient, the Java Virtual Machine (JVM) skips it during serialization, and its value is not saved. 
Upon deserialization, the transient field will be initialized to its default value (e.g., null for objects, 0 for integers).

Typical use cases for the transient keyword include:
Protecting sensitive information (e.g., passwords, authentication tokens)
Excluding temporary or derived data
Avoiding serialization of runtime-specific resources (e.g., database connections, file streams)
-------------------------------------------------------------------------------------------------------------------
Explain the concept of Java Generics and its advantages.

xplain the concept of Java Generics and its advantages.
Java Generics is a feature that allows classes, interfaces, and methods to operate on different data types while providing compile-time type safety. 
By using type parameters (such as <T>, <E>, etc.), generics enable developers to write more flexible and reusable code that can work with any reference type, 
rather than being limited to a specific class.

Concept of Java Generics
Generic Classes and Interfaces: You can define a class or interface with type parameters, making it adaptable to various data types. 
For example, ArrayList<T> can store any type of objects specified at instantiation.
Generic Methods: Methods can be defined with type parameters, allowing them to operate on different data types without duplicating code.
Type Parameterization: Type parameters are specified in angle brackets (<>) and allow the same code to handle multiple types safely.

Advantages of Java Generics
Type Safety: Generics enforce compile-time type checking, reducing the risk of runtime ClassCastException and ensuring that only compatible types are used.
Code Reusability: You can write a single class, interface, or method that works with different data types, avoiding code duplication and making maintenance easier.
Elimination of Explicit Casting: With generics, you don‚Äôt need to cast objects when retrieving them from collections, making code cleaner and less error-prone.
Improved Readability and Maintainability: Generics make code easier to read and maintain by clearly specifying the intended data types and reducing boilerplate code.
Performance: By avoiding unnecessary casting and enabling compile-time checks, generics can improve performance and reduce runtime overhead

-------------------------------------------------------------------------------------------------------------------

What are functional interfaces and how are they used in Java 8?

What is a Functional Interface?
A functional interface contains only one abstract method, though it can have multiple default or static methods.
The @FunctionalInterface annotation is used for clarity and to instruct the compiler to enforce this rule, but it is not mandatory.
Common examples: Runnable, Callable, Comparator, and new Java 8 interfaces like Function, Predicate, Consumer, and Supplier.

How Are Functional Interfaces Used in Java 8?

1. Lambda Expressions
Functional interfaces are the target types for lambda expressions, enabling concise and readable code:
Predicate<String> isEmpty = s -> s.isEmpty();
Here, Predicate<T> is a functional interface, and the lambda provides its implementation.

2. Method References
They also serve as targets for method references:
Consumer<String> printer = System.out::println;

3. Stream API and Functional Programming
Functional interfaces are widely used in the Java 8 Stream API, allowing operations like filtering, mapping, and consuming elements:
List<String> names = Arrays.asList("Alice", "Bob");
names.forEach(name -> System.out.println(name)); // Consumer<T>
names.stream().filter(s -> s.length() > 3).collect(Collectors.toList()); // Predicate<T>

Interface	            Abstract                   Method Description
Predicate<T>	         boolean test(T t)	      Tests a condition and returns a boolean
Function<T,R>	         R apply(T t)	          Takes an input and returns a result
Consumer<T>	             void accept(T t)	      Performs an action on an input, returns nothing
Supplier<T>	             T get()	              Supplies a result, takes no input
BiFunction<T,U,R>	     R apply(T t, U u)	      Takes two inputs, returns a result
BiPredicate<T,U>	     boolean test(T t, U u) 	Tests a condition on two inputs, returns a boolean
BinaryOperator<T>	     T apply(T t1, T t2)	  Operates on two values of the same type, returns a value

-------------------------------------------------------------------------------------------------------------------

What is the Stream API in Java 8 and how does it help in processing data?

The Stream API in Java 8 is a powerful feature that enables functional-style operations on sequences of elements, such as collections or arrays. 
It allows developers to process data in a more concise, declarative, and readable manner compared to traditional loops.

What is the Stream API?
A stream is a sequence of elements that supports various operations which can be pipelined to produce a desired result.
Streams do not store data; they operate on the source data structure (like a collection or array) and process elements on demand.
The Stream API was introduced to overcome the limitations of external iteration (using loops) by providing internal iteration 
and enabling operations such as filtering, mapping, sorting, and reducing data.

How Does the Stream API Help in Processing Data?

1. Declarative Data Processing
Streams allow you to express complex data processing queries in a clear and concise way, similar to SQL-like operations.
Example: Filtering, mapping, and collecting data can be done in a single pipeline:
List<String> result = names.stream()
    .filter(name -> name.startsWith("A"))
    .sorted()
    .collect(Collectors.toList());
	
2. Chaining Operations
Streams support intermediate operations (like filter, map, distinct, sorted) that transform the stream, 
and terminal operations (like collect, forEach, reduce) that produce a result or side effect.
Multiple intermediate operations can be chained to build complex data processing pipelines.

3. Parallel Processing
Streams can be processed in parallel simply by using parallelStream(), which can improve performance for large data sets by leveraging multicore processors.

4. Improved Readability and Maintainability
Code using the Stream API is often shorter and easier to understand compared to traditional for-loops and manual iteration.

5. Functional Programming Integration
The Stream API works seamlessly with lambda expressions and functional interfaces, enabling a functional programming style in Java.

Example

List<Integer> numbers = Arrays.asList(5, 10, 15, 20, 25);
int sum = numbers.stream()
    .filter(n -> n > 10)
    .mapToInt(Integer::intValue)
    .sum();
	
This code filters numbers greater than 10 and computes their sum in a single, readable pipeline

-------------------------------------------------------------------------------------------------------------------

what is object ?

In java object is an instance of a class hving the instance variables like the state of the object and the methods as the behaviour of the object.
The Object of a class can be created by using the new keyword.

------------------------------------------------------------------------------------

what is class ?

A class in Java is a blueprint or template that defines the properties (attributes/fields) and behaviors (methods/functions) of objects

------------------------------------------------------------------------------------

what is abstraction ?

Abstraction in Java is an object-oriented programming concept that involves hiding the complex implementation details of a system 
and exposing only the essential features or functionalities to the user. This allows developers and users to interact with objects or systems 
without needing to understand or deal with their internal workings.

------------------------------------------------------------------------------------

what is encapsulation ?
Encapsulation is a process of wrapping of data and methods in a single unit is called encapsulation.
In OOP, data and methods operating on that data are combined together to form a single unit, which is referred to as a Class.

Abstraction is implemented in Java using interface and abstract class
while Encapsulation is implemented using private, package-private and protected access modifiers.
Abstraction solves the problem in the design level. Whereas Encapsulation solves the problem in the implementation level.

------------------------------------------------------------------------------------

what is inheritance ?

The Inheritance is a process of obtaining the data members and methods from one class to another class, plus can have its own is known as inheritance. 
It is one of the fundamental features of object-oriented programming.
Inheritance - IS-A relationship between a superclass and its subclasses.

single -level
Multi-level
Hierarchical
Multiple
Hybrid

Is-A Relationship
------------------
Definition:
The is-a relationship represents inheritance between classes. It means one class (the child or subclass) is a specialized type of another class (the parent or superclass).

How it‚Äôs implemented:
Achieved using the extends keyword for class inheritance or implements for interface inheritance in Java.

Example:
Car extends Vehicle ‚Üí A Car is a Vehicle.
Dog extends Animal ‚Üí A Dog is an Animal.

Has-A Relationship
-----------------
Definition:
The has-a relationship represents association or composition between classes. It means one class contains a reference to another class as a field, indicating ownership or usage.

How it‚Äôs implemented:
Achieved by declaring an instance variable of one class inside another class (object composition).

Example:
Car has an Engine ‚Üí The Car class contains an Engine object.
House has a Room ‚Üí The House class contains Room objects.

------------------------------------------------------------------------------------

what is polymorphism ?

The process of representing one form in multiple forms is known as Polymorphism.

1. Compile time polymorphism or method overloading or static binding
2. Runtime polymorphism or method overriding or dynamic binding

static v/s dynamic & Compile-time v/s Run-time
----------------------------------------------
Static Polymorphism (Compile-Time Polymorphism)
Static polymorphism is resolved at compile time. The compiler determines which method to call based on the method signature (name, number, and type of parameters).
class Calculator {
    int add(int a, int b) { return a + b; }
    double add(double a, double b) { return a + b; }
    int add(int a, int b, int c) { return a + b + c; }
}

Dynamic Polymorphism (Run-Time Polymorphism)
Dynamic polymorphism is resolved at runtime. The Java Virtual Machine (JVM) determines which method to execute based on the actual object type, not the reference type.
class Animal {
    void makeSound() { System.out.println("Some sound"); }
}
class Dog extends Animal {
    @Override
    void makeSound() { System.out.println("Woof!"); }
}
Animal a = new Dog();
a.makeSound(); // Output: Woof!

overloading v/s Overriding
----------------------------------------------
Overloading is about having multiple methods with the same name but different parameters within the same class (compile-time).
Overriding is about redefining a superclass method in a subclass with the same signature (runtime)

------------------------------------------------------------------------------------
JDK v/s JRE v/s JVM

JDK (Java Development Kit)
Purpose: Complete software development kit for Java.
Includes: JRE (Java Runtime Environment), development tools like compiler (javac), debugger, and other utilities.
Use Case: Needed for developing, compiling, and running Java applications.
Platform Dependency: Platform-dependent (separate installers for Windows, Mac, Linux).
Summary: If you want to write and compile Java code, you need the JDK.

JRE (Java Runtime Environment)
Purpose: Provides the environment to run Java applications.
Includes: JVM (Java Virtual Machine), core libraries, and supporting files required for execution.
Use Case: Needed only for running (not developing) Java applications.
Platform Dependency: Platform-dependent (separate installers).
Summary: If you just want to run Java programs, JRE is sufficient.

JVM (Java Virtual Machine)
Purpose: Abstract machine that executes Java bytecode.
Includes: Only the runtime environment for interpreting and executing bytecode.
Use Case: Core component for running Java programs; provides platform independence by translating bytecode to machine-specific code.
Platform Dependency: JVM specification is platform-independent; implementations are platform-dependent.
Summary: JVM is the engine that runs Java code and is included inside both JRE and JDK.
-----------------------------------------------------------------------------------------------------
Serilazation and where you used in project?

Serialization is the process of converting an object‚Äôs state into a format (such as a byte stream or JSON/XML string) 
that can be stored (in a file, database, or cache) or transmitted (over a network), and later reconstructed back into an identical object 
through deserialization.

By default, only non-static, non-transient fields are serialized, and only if their types are also serializable.
Web APIs use JSON/XML and serialize objects through third-party libraries (Jackson), not Java‚Äôs native serialization -
Java applications use Object-Relational Mapping (ORM) frameworks like JPA (Hibernate) or write SQL queries to manually convert objects 
into rows and store primitive values (e.g., strings, ints, dates) in database columns.
Java serialization = specific to serializing Java objects using Serializable.
PDF, Excel, JSON, XML, etc. are external formats, not tied to Java‚Äôs serialization system.

usecase:-
redis :- when i was trying to save the data in to redis cache , i faced error for the field type LOcalDateTime, so is used Custom DE/Serialization
by using JsonDE/Serialization

--------------------------------------------------------------------------------------------------
How Java code compiled?

jdk -> compile (compiler) -> bytecode
jre -> runs the program
jvm -> converts bytecode to binary lanuage.

1. Writing Source Code
You write your Java code in files with the .java extension using a text editor or an IDE.

2. Compiling Source Code
The Java compiler (javac) takes your .java files and compiles them.
During compilation, the compiler checks for syntax errors and converts the source code into bytecode.
Bytecode is stored in .class files and is not specific to any platform

3.Executing Bytecode
The Java Virtual Machine (JVM) loads and executes the bytecode.
The JVM interprets or just-in-time (JIT) compiles the bytecode into machine code specific to the operating system and hardware.
This is what makes Java "write once, run anywhere": the same bytecode can run on any system with a compatible JVM

-----------------------------------------------------------------------------------------------------------
Singleton usage and it's program?

The Singleton pattern is a creational design pattern that ensures a class has only one instance and provides a global point of access to it.
This is useful when exactly one object is needed to coordinate actions across the system.

Single-ton implementation can be done
1. Classic (Lazy Initialization, Not Thread-Safe)
2. Thread-Safe (Bill Pugh Singleton Implementation)
3. Enum Singleton (Best Practice)

Common Use Cases
Configuration management: Only one configuration object should exist throughout the application.
Logging: A single logger instance for consistent logging.
Caching: Centralized cache manager.
Thread pools, driver objects, or resource managers: To avoid multiple resource-intensive instances

public enum ConfigManager {
    INSTANCE;

    private Properties config;

    // Initialize configuration in the constructor (called once)
    ConfigManager() {
        config = new Properties();
        try (InputStream input = new FileInputStream("config.properties")) {
            config.load(input);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public String getProperty(String key) {
        return config.getProperty(key);
    }

    public void setProperty(String key, String value) {
        config.setProperty(key, value);
    }
}

String dbUrl = ConfigManager.INSTANCE.getProperty("db.url");
ConfigManager.INSTANCE.setProperty("app.name", "MyApp");

-----------------------------------------------------------------------------------------------------------
why Strings are immutable?

Strings are immutable in Java because, once created, their value cannot be changed. Any operation that seems to modify a String actually 
creates a new String object. 

1. Security
Strings are often used for sensitive data (like file paths, class names, network connections, and passwords).
Immutability ensures that once a String is created, its value cannot be changed by malicious code or accidentally altered, 
which is crucial for security-sensitive operations such as class loading and network connections

2. String Pooling (Memory Efficiency)
Java maintains a String pool to store unique String literals.
When multiple references point to the same literal, they all share the same memory location.

3. Thread Safety
Immutable objects are inherently thread-safe because their state cannot change after creation.
This allows Strings to be safely shared between threads without synchronization.

4. Hashcode Caching
Strings are commonly used as keys in hash-based collections (like HashMap or HashSet).

5. Class Loading Reliability
The Java class loader relies on Strings for loading classes by name.
Immutability ensures that the class name cannot be changed once loaded, which is critical for the integrity of the class loading process

-----------------------------------------------------------------------------------------------------------
what is thread life cycle?

NEW
 ‚Üì (start())
RUNNABLE
 ‚Üô           ‚Üò
WAITING   BLOCKED
 ‚Üò           ‚Üô
  TIMED_WAITING
       ‚Üì
 TERMINATED

-----------------------------------------------------------------------------------------------------------

Explain hashmap internal working?

A HashMap is a key-value data structure that allows fast lookup, insertion, and deletion of elements. It's part of java.util and 
uses hashing to store and retrieve entries in constant time on average.

| Concept            | Description                                              |
| ------------------ | -------------------------------------------------------- |
| **Key & Value**    | Every entry is a pair of key and value                   |
| **Hash Function**  | Converts key into an integer (the hash code)             |
| **Bucket (Index)** | The hash code is mapped to an index in an internal array |
| **Collision**      | When two keys map to the same index                      |
| **Load Factor**    | When to resize the internal array (default is `0.75`)    |

Internally, a HashMap uses an array of buckets. Each bucket can be:
null (empty),
A single Node<K,V>,
Or a linked list or balanced tree (if many keys collide).

-----------------------------------------------------------------------------------------------------------
Explain fails fast and fails safe?

Fail-fast iterators immediately throw a ConcurrentModificationException if a collection is modified structurally (e.g., add/remove)
after the iterator is created ‚Äî except through the iterator itself.

List<String> list = new ArrayList<>();
list.add("A");
list.add("B");

for (String item : list) {
    list.remove(item);  // ‚ùå Throws ConcurrentModificationException
}

Fail-safe iterators do not throw an exception even if the collection is modified during iteration. They usually operate on a clone (snapshot) 
of the collection.

CopyOnWriteArrayList<String> list = new CopyOnWriteArrayList<>();
list.add("A");
list.add("B");

for (String item : list) {
    list.remove(item);  // ‚úÖ No exception
}
-----------------------
list.removeIf(item -> item.equals("B"));
----------------------------
Iterator<String> iterator = list.iterator();
while (iterator.hasNext()) {
    String item = iterator.next();
    if (item.equals("B")) {
        iterator.remove(); // Safe removal
    }
}

-----------------------------------------------------------------------------------------------------------
what is the use of concurrent hash map?

ConcurrentHashMap is a thread-safe, high-performance version of HashMap designed for use in multi-threaded environments. 
It allows concurrent reads and writes without requiring external synchronization.

It does not allow null keys or values.
map.put(null, "value"); // ‚ùå NullPointerException
Operations like put(), get(), remove() are highly optimized for concurrency.
It doesn‚Äôt guarantee any iteration order ‚Äî it's unordered.

-----------------------------------------------------------------------------------------------------------
what is the output for list.remove(2)?

remove(int index) ‚Üí removes by position
remove(Object o) ‚Üí removes the first occurrence of the object

It removes the element at index 2 from the list.
Returns the removed element.
Throws IndexOutOfBoundsException if index 2 is invalid.

List<String> list = new ArrayList<>();
list.add("A"); // index 0
list.add("B"); // index 1
list.add("C"); // index 2
list.add("D"); // index 3

String removed = list.remove(2);
System.out.println(removed);        // Output: C
System.out.println(list);           // Output: [A, B, D]

| Code                              | Result                            |
| --------------------------------- | --------------------------------- |
| `list.remove(2)`                  | Removes element at **index 2**    |
| `list.remove((Integer) 2)`        | Removes **value 2** (first match) |
| `list.remove(Integer.valueOf(2))` | Same ‚Äî removes **value 2**        |

----------------------------------------------------------------------------------------------------------------------
what is volatile keyword in java ?

The volatile keyword in Java is used to indicate that a variable's value may be modified by multiple threads and that reads and writes to that variable are immediately visible to all threads.

‚úÖ Definition
volatile dataType variableName;

üîç What It Does:

Ensures Visibility:
Changes made by one thread to a volatile variable are immediately visible to all other threads.
Without volatile, a thread may cache the variable and not see updates made by other threads.

Prevents Caching / Reordering:
The variable is always read from and written to main memory.
The JVM and CPU won't reorder instructions involving the volatile variable.

‚ùå What It Does NOT Do:

It does not guarantee atomicity of compound actions like x++, x = x + 1, etc.
For atomic operations, use AtomicInteger, synchronized, or locks.

‚úÖ Example

public class SharedObject {
    private volatile boolean flag = false;

    public void writer() {
        flag = true; // change is visible to all threads
    }

    public void reader() {
        if (flag) {
            System.out.println("Flag was set to true");
        }
    }
}
Without volatile, the reader() thread might never see the updated value of flag.

üîÑ When to Use volatile
When multiple threads read/write a simple boolean or status flag.
For safe publication of a variable without using synchronization.
When you don‚Äôt need full synchronization but just visibility guarantees.

‚ö†Ô∏è When Not to Use
For compound or multi-step operations (counter++, balance -= amount) ‚Äì not thread-safe.
When needing mutual exclusion ‚Äì use synchronized or ReentrantLock.

-----------------------------------------------------------------------------------------------------------------------------------------------------------
breifly explain about Runnable and Callable ?

Both Runnable and Callable are interfaces used to define tasks that can be executed by threads, but they have key differences:

‚úÖ Runnable

Interface: java.lang.Runnable

Method: void run()

Characteristics:
Doesn't return any result
Cannot throw checked exceptions
Basic threading construct since Java 1.0

Usage:

Runnable task = () -> {
    System.out.println("Running task");
};
new Thread(task).start();

‚úÖ Callable

Interface: java.util.concurrent.Callable<V>

Method: V call() throws Exception

Characteristics:
Returns a result (generic type V)
Can throw checked exceptions
Introduced in Java 5 as part of the Concurrency API

Usage:

Callable<String> task = () -> {
    return "Task result";
};
ExecutorService executor = Executors.newSingleThreadExecutor();
Future<String> future = executor.submit(task);

When to Use Which
----------------
Use Runnable for fire-and-forget tasks

Use Callable when you need:
A return value
Exception handling
Integration with ExecutorService and Future

Example with ExecutorService

ExecutorService executor = Executors.newFixedThreadPool(2);

// Runnable
executor.execute(() -> System.out.println("Runnable task"));

// Callable
Future<Integer> future = executor.submit(() -> {
    return 42; // Returns a value
});

Integer result = future.get(); // Blocks until result is available
----------------------------------------------------------------------------------------------------------------------------------------------
‚úÖ What are the different types of memory in JVM (Heap, Stack, Metaspace)?

1Ô∏è‚É£ Heap Memory ‚Äì "Where all objects live"
It's the main memory where objects are created using new.

It‚Äôs divided into:
Young Generation (Eden + Survivor)
Old Generation (Tenured)

Garbage Collection mainly happens here.

üìå In my project:
I once debugged an OutOfMemoryError when a service processed a huge file. We analyzed the heap dump to check memory leaks.

2Ô∏è‚É£ Stack Memory ‚Äì "Where methods run"
Stores method calls, local variables, and references.
Each thread has its own stack.
It's faster but limited in size.

üìå Example:
If you have deep recursion, it can cause a StackOverflowError ‚Äî I faced this once during a file processing loop by mistake.

3Ô∏è‚É£ Metaspace ‚Äì "Stores class metadata"
Replaced PermGen in Java 8.
It stores class definitions (like structure of classes, methods, etc.)
Grows automatically based on the classes loaded.

üìå In real usage:
Once we added a lot of third-party libraries, and JVM threw a Metaspace OutOfMemoryError. We fixed it by increasing -XX:MaxMetaspaceSize.
------------------------------------------------------------------------------------------------------------------------------------------------------------------
what is class Loader in java ?

In Java, a ClassLoader is a part of the Java Runtime Environment (JRE) responsible for loading .class files (Java bytecode) into memory when needed during execution.
It converts the .class file ‚Üí Class object so it can be used by the JVM.

üß† Why is ClassLoader Important?

Java uses dynamic loading, which means:
Classes are not loaded into memory at program startup.
They are loaded only when required, by the ClassLoader.

üîç Types of ClassLoaders in Java
| ClassLoader                         | Parent    | Loads From                    | Role                                                          |
| ----------------------------------- | --------- | ----------------------------- | ------------------------------------------------------------- |
| **Bootstrap ClassLoader**           | ‚Äî         | `rt.jar` or core Java classes | Loads Java core classes (`java.lang.*`, etc.)                 |
| **Extension ClassLoader**           | Bootstrap | `lib/ext`                     | Loads classes from Java extensions                            |
| **System/Application ClassLoader**  | Extension | `classpath`                   | Loads application-level classes                               |
| **Custom/User-defined ClassLoader** | Any       | Custom path or logic          | Used to load classes from a DB, network, encrypted file, etc. |
------------------------------------------------------------------------------------------------------------------------------------------------------------------



